#version 430

#define M_PI 3.141592654f
#define BOARD_X 30.0
#define BOARD_Y 30.0
#define TEX_X 256
#define TEX_Y 256
#define TEXEL_DIM min(BOARD_X/TEX_X, BOARD_Y/TEX_X)

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0, rgba32f) uniform image2D imageUnit;
uniform sampler2D wind_texture;
uniform sampler2D obstacle_normals_texture;

uniform vec3 wind_direction;
uniform int wind_type;

vec4 random_intensity_fixed_direction() {

    return vec4(wind_direction.x, wind_direction.y, wind_direction.z, 1.0);

}

vec4 random_intensity_fixed_direction(vec4 wind_dir) {

    return vec4(wind_dir.x, wind_dir.y, wind_dir.z, 1.0);

}

vec4 vortex(float strength, float radius, float angle) {

    float v_r = 0.0f;
    float v_theta = strength / ( 2.0f * M_PI * radius );
    float v_z = 0.0f;
    float potencial = strength / ( 2.0f * M_PI ) * angle;

    return vec4(v_r, v_theta, v_z, potencial);

}

vec4 vortex_effect( vec4 wind_position ){

    vec4 pos = vec4(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, 1,1);
    float position_x = (pos.x * BOARD_X / TEX_X ) - BOARD_X / 2.0f; // Centering on (0,0)
    float position_y = (pos.y * BOARD_Y / TEX_Y ) - BOARD_Y / 2.0f; // Centering on (0,0)

    float radius = length(vec2(position_x - wind_position.x, position_y - wind_position.y));
    float theta = atan( position_y - wind_position.y , position_x - wind_position.x );

    vec4 polar_velocity = vortex(1, radius, theta);

	float new_radius = radius + polar_velocity.x;
	float new_theta  = theta + polar_velocity.y;

	float new_position_x = new_radius * cos (new_theta) + wind_position.x;
	float new_position_y = new_radius * sin (new_theta) + wind_position.y;

    vec4 wind_dir = (vec4(new_position_x, 0, new_position_y, 1) - vec4 (position_x, 0, position_y, 0));

	return wind_dir;
}


vec4 sink_source(float strength, float radius, float angle) {

    float v_r = strength / ( 2.0f * M_PI * radius );
    float v_theta = 0.0f;
    float v_z = 0.0f;
    float potencial = strength / ( 2.0f * M_PI ) * log(radius);

    return vec4(v_r, v_theta, v_z, potencial);

}

vec4 sink_source_effect(int type, vec4 wind_position){

    vec4 pos = vec4(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, 1, 1);
    float position_x = (pos.x * BOARD_X / TEX_X ) - BOARD_X / 2.0f; // Centering on (0,0)
    float position_y = (pos.y * BOARD_Y / TEX_Y ) - BOARD_Y / 2.0f; // Centering on (0,0)

    float radius = length(vec2(position_x - wind_position.x, position_y - wind_position.y));
    float theta = atan(position_y - wind_position.y, position_x - wind_position.x );

    vec4 polar_velocity = sink_source(type * 50, radius , theta);

	float new_radius = radius + polar_velocity.x;
	float new_theta  = theta + polar_velocity.y;

	float new_position_x = new_radius * cos (new_theta) + wind_position.x;
	float new_position_y = new_radius * sin (new_theta) + wind_position.y;

    vec4 wind_dir = (vec4(new_position_x, 0, new_position_y, 1) - vec4 (position_x, 0, position_y, 0));

    // Check for wall in between
    int between_steps = 500;
    
    vec2 tex_pos = gl_GlobalInvocationID.xy;
    vec2 current_texel = tex_pos;
    vec2 source_dir = ((wind_position.xz + BOARD_X * 0.5) / BOARD_X * 256) - tex_pos;
    vec2 source_dir_step = normalize(source_dir) * TEXEL_DIM;
    vec4 normal = vec4(0.0, 0.0, 0.0, 0.0);
    
    int step = 0; bool wall_between = false;
    for (; step < between_steps; step++) {
                
        if (length(source_dir_step * step) > length(source_dir)) break;

        ivec2 texel = ivec2(tex_pos + source_dir_step * step);

        if (texel == current_texel) continue;
        else {
                    
            current_texel = texel;

            normal = texelFetch(obstacle_normals_texture, texel, 0);

            //if (normal != vec4(0.0, 0.0, 0.0, 0.0)) { wall_between = true; break; }

            vec2 normal_xz = normalize(normal).xz;
            vec2 parallel_xz = vec2(normal_xz.y, -normal_xz.x);
            vec2 source_dir_xz = normalize(source_dir);

            float dot_normal_source = dot (normal_xz, source_dir_xz);

            if (dot_normal_source < 0.0) {wall_between = true; break;}

        }

    }

    if (wall_between) wind_dir = mix (normalize(wind_dir) * 0.0001, wind_dir, float(step) / float(between_steps));
    else {

        // Check for wall after
        int after_steps = 900;
        
        vec2 away_source_dir = tex_pos - ((wind_position.xz + BOARD_X * 0.5) / BOARD_X * 256);
        vec2 away_source_dir_step = normalize(away_source_dir) * TEXEL_DIM;
        //vec2 wind_dir_step = vec2(normalize(wind_dir).xz) * TEXEL_DIM;
        vec2 parallel = vec2(0.0, 0.0);

        int step = 0; bool wall_after = false;
        for (; step < after_steps; step++) {
                    
            ivec2 texel = ivec2(tex_pos + away_source_dir_step * step);

            if (texel == current_texel) continue;
            else {
                        
                current_texel = texel;

                normal = texelFetch(obstacle_normals_texture, texel, 0);

                vec2 normal_xz = normalize(normal).xz;
                vec2 parallel_xz = vec2(normal_xz.y, -normal_xz.x);
                vec2 away_source_dir_xz = normalize(away_source_dir);

                float dot_away_parallel = dot( parallel_xz, away_source_dir_xz );

                if ( dot_away_parallel > 0.0 ) parallel_xz = - parallel_xz;
                
                parallel = normalize(parallel_xz) * length(wind_dir);

                float dot_normal_source = dot (normal_xz, away_source_dir_xz);

                if (dot_normal_source < 0.0) {wall_after = true; break;}

            }

        }

        float smoo = smoothstep(0, after_steps, step);

        if (wall_after) wind_dir = mix (normalize(vec4(parallel.x, 0.0, parallel.y, 1.0)) * length(wind_dir), wind_dir, smoo);
    
    }

    
	return wind_dir;

}

vec4 get_cons_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    // Constant
    for (int i=99; i >= 0 && done; i--) {
        
        vec4 holder = texelFetch (wind_texture , ivec2(0, i), 0);
        
        if (holder.w == 0) done = false;
        else {

            wind += random_intensity_fixed_direction(holder);

        }
    
    }

    return wind;

}

vec4 get_vortex_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    for (int i=99; i >= 0 && done; i--) {

        vec4 holder = texelFetch (wind_texture , ivec2(1, i) , 0);

        if (holder.w == 0) done = false;
        else {

            holder.x = (holder.x * BOARD_X) - BOARD_X * 0.5;
            holder.y = (holder.y * BOARD_X) - BOARD_X * 0.5;
            holder.z = (holder.z * BOARD_Y) - BOARD_Y * 0.5;

            wind += vortex_effect( holder );

        }
    }

    return wind;

}

vec4 get_sink_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    for (int i=99; i >= 0 && done; i--) {

        vec4 holder = texelFetch (wind_texture , ivec2(2, i) , 0);
        
        if(holder.w == 0) done = false;
        else {

            holder.x = (holder.x * BOARD_X) - BOARD_X * 0.5;
            holder.y = (holder.y * BOARD_X) - BOARD_X * 0.5;
            holder.z = (holder.z * BOARD_Y) - BOARD_Y * 0.5;
            
            wind += sink_source_effect( 1, holder);

        }
    }

    return wind;

}

vec4 get_source_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    vec2 texel_dim = vec2(float(BOARD_X) / float(TEX_X), float(BOARD_Y) / float(TEX_Y));
    vec2 tex_pos = gl_GlobalInvocationID.xy;

    for (int i=99; i >= 0 && done; i--) {

        vec4 holder = texelFetch (wind_texture, ivec2(3, i) , 0);
        
        if (holder.w == 0) done = false;
        else {
            
            vec2 source_dir = (holder.xy * 256.0) - tex_pos;
            vec2 source_dir_norm = normalize(source_dir) * texel_dim;
            vec4 normal = texelFetch(obstacle_normals_texture, ivec2(tex_pos), 0);

            holder.x = (holder.x * BOARD_X) - BOARD_X * 0.5;
            holder.y = (holder.y * BOARD_X) - BOARD_X * 0.5;
            holder.z = (holder.z * BOARD_Y) - BOARD_Y * 0.5;
            
            wind += 10 * sink_source_effect( -1, holder);
            
        }
    }

    return wind;

}

void main() {

	ivec2 storeLoc = ivec2(gl_GlobalInvocationID.xy);

	vec4 stored = imageLoad( imageUnit, storeLoc );

	vec4 wind = vec4(0,0,0,0);

	switch (wind_type) {
		
		case 0:
			
			wind = random_intensity_fixed_direction();
			break;
		
		case 1:

			wind = vortex_effect( vec4(-1,-2,0,10) );
			break;

		case 2:

			wind = sink_source_effect( -1 , vec4( -5,6,0,10)); // source
			break;

		case 3:

			wind = sink_source_effect( 1 , vec4(-3,-3,0,10)); // sink 
			break; 

        case 4:

            wind += get_cons_wind_from_tex();
            wind += get_vortex_wind_from_tex();
            wind += get_sink_wind_from_tex();            
            wind += get_source_wind_from_tex();

            break;
            
		default:

			wind = random_intensity_fixed_direction();
			break;

	} 

	imageStore(imageUnit, storeLoc, wind);
}