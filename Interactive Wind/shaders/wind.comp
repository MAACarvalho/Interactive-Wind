#version 430

#define M_PI 3.141592654f
#define BOARD_X 30
#define BOARD_Y 30
#define TEX_X 256
#define TEX_Y 256

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0, rgba32f) uniform image2D imageUnit;
uniform sampler2D wind_texture;
uniform sampler2D obstacle_normals_texture;

uniform vec3 wind_direction;
uniform int wind_type;

vec4 random_intensity_fixed_direction() {

    return vec4(wind_direction.x, wind_direction.y, wind_direction.z, 1.0);

}

vec4 random_intensity_fixed_direction(vec4 wind_dir) {

    return vec4(wind_dir.x, wind_dir.y, wind_dir.z, 1.0);

}

vec4 vortex(float strength, float radius, float angle) {

    float v_r = 0.0f;
    float v_theta = strength / ( 2.0f * M_PI * radius );
    float v_z = 0.0f;
    float potencial = strength / ( 2.0f * M_PI ) * angle;

    return vec4(v_r, v_theta, v_z, potencial);

}

vec4 vortex_effect( vec4 wind_position ){

    vec4 pos = vec4(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, 1,1);
    float position_x = (pos.x * BOARD_X / TEX_X ) - BOARD_X / 2.0f; // Centering on (0,0)
    float position_y = (pos.y * BOARD_Y / TEX_Y ) - BOARD_Y / 2.0f; // Centering on (0,0)

    float radius = length(vec2(position_x - wind_position.x, position_y - wind_position.y));
    float theta = atan( position_y - wind_position.y , position_x - wind_position.x );

    vec4 polar_velocity = vortex(1, radius, theta);

	float new_radius = radius + polar_velocity.x;
	float new_theta  = theta + polar_velocity.y;

	float new_position_x = new_radius * cos (new_theta) + wind_position.x;
	float new_position_y = new_radius * sin (new_theta) + wind_position.y;

    vec4 wind_dir = (vec4(new_position_x, 0, new_position_y, 1) - vec4 (position_x, 0, position_y, 0));

	return wind_dir;
}


vec4 sink_source(float strength, float radius, float angle) {

    float v_r = strength / ( 2.0f * M_PI * radius );
    float v_theta = 0.0f;
    float v_z = 0.0f;
    float potencial = strength / ( 2.0f * M_PI ) * log(radius);

    return vec4(v_r, v_theta, v_z, potencial);

}

vec4 sink_source_effect(int type, vec4 wind_position, vec4 normal){

    vec4 pos = vec4(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, 1, 1);
    float position_x = (pos.x * BOARD_X / TEX_X ) - BOARD_X / 2.0f; // Centering on (0,0)
    float position_y = (pos.y * BOARD_Y / TEX_Y ) - BOARD_Y / 2.0f; // Centering on (0,0)

    float radius = length(vec2(position_x - wind_position.x, position_y - wind_position.y));
    float theta = atan(position_y - wind_position.y, position_x - wind_position.x );

    vec4 polar_velocity = sink_source(type * 10, radius , theta);

	float new_radius = radius + polar_velocity.x;
	float new_theta  = theta + polar_velocity.y;

	float new_position_x = new_radius * cos (new_theta) + wind_position.x;
	float new_position_y = new_radius * sin (new_theta) + wind_position.y;

    vec4 wind_dir = (vec4(new_position_x, 0, new_position_y, 1) - vec4 (position_x, 0, position_y, 0));

    if ( normal != vec4(0.0, 0.0, 0.0, 0.0)) {
        float tamanho = length(wind_dir);
        vec4 new_direction, best_direction;
        float dot_product = dot( normalize( normal ) , normalize( wind_dir ) );

        new_direction = vec4( -normal.z, normal.y, normal.x, normal.w);
        dot_product = dot( normalize( wind_dir ) , normalize( new_direction ) );
        
        

        // Counter Clock wise
        //if ( dot_product  > 0.0f)
            //new_direction = vec4( -normal.z, wind_dir.y, normal.x, wind_dir.w);
        // Clock wise
        //else 
            //new_direction = vec4(0.0, 100.0, 0.0, 0.0);
            //new_direction = vec4( normal.z, wind_dir.y, -normal.x, wind_dir.w);
        
        //dot_product = dot( normalize( vec4( -normal.z, normal.y, normal.x, normal.w) ), normalize( normal ) );

        if ( dot_product > 0.0f)
            new_direction = vec4( normal.z, normal.y, -normal.x, normal.w);

        best_direction = new_direction;//mix( wind_dir , new_direction , abs(dot_product) );

        wind_dir = best_direction;
    }

	return wind_dir;

}

vec4 get_cons_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    // Constant
    for (int i=99; i >= 0 && done; i--) {
        
        vec4 holder = texelFetch (wind_texture , ivec2(0, i), 0);
        
        if (holder.w == 0) done = false;
        else {

            wind += random_intensity_fixed_direction(holder);

        }
    
    }

    return wind;

}

vec4 get_vortex_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    for (int i=99; i >= 0 && done; i--) {

        vec4 holder = texelFetch (wind_texture , ivec2(1, i) , 0);

        if (holder.w == 0) done = false;
        else {

            holder.x = (holder.x * BOARD_X) - BOARD_X * 0.5;
            holder.y = (holder.y * BOARD_X) - BOARD_X * 0.5;
            holder.z = (holder.z * BOARD_Y) - BOARD_Y * 0.5;

            wind += vortex_effect( holder );

        }
    }

    return wind;

}

vec4 get_sink_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    for (int i=99; i >= 0 && done; i--) {

        vec4 holder = texelFetch (wind_texture , ivec2(2, i) , 0);
        
        if(holder.w == 0) done = false;
        else {

            holder.x = (holder.x * BOARD_X) - BOARD_X * 0.5;
            holder.y = (holder.y * BOARD_X) - BOARD_X * 0.5;
            holder.z = (holder.z * BOARD_Y) - BOARD_Y * 0.5;
            
            wind += sink_source_effect( 1, holder , vec4(0,0,0,0));

        }
    }

    return wind;

}

/*
vec4 get_source_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    vec2 texel_dim = vec2(float(BOARD_X) / float(TEX_X), float(BOARD_Y) / float(TEX_Y));
    vec2 tex_pos = gl_GlobalInvocationID.xy;

    for (int i=99; i >= 0 && done; i--) {

        vec4 holder = texelFetch (wind_texture, ivec2(3, i) , 0);
        
        if (holder.w == 0) done = false;
        else {
            
            vec2 source_dir = (holder.xy * 256.0) - tex_pos;
            vec2 source_dir_norm = normalize(source_dir) * texel_dim;

            vec2 current_texel = tex_pos;

            int j = 0; bool occluded = false;
            while (true) {

                j++;
                
                if (length(source_dir_norm * j) > length(source_dir)) break;

                ivec2 texel = ivec2(tex_pos + source_dir_norm * j);

                if (texel == current_texel) continue;
                else {
                    
                    current_texel = texel;

                    vec4 normal = texelFetch(obstacle_normals_texture, texel, 0);

                    if (normal != vec4(0.0, 0.0, 0.0, 0.0)) {occluded = true; break; }

                }


            }

            if (!occluded) {

                holder.x = (holder.x * BOARD_X) - BOARD_X * 0.5;
                holder.y = (holder.y * BOARD_X) - BOARD_X * 0.5;
                holder.z = (holder.z * BOARD_Y) - BOARD_Y * 0.5;
                
                wind += 10 * sink_source_effect( -1, holder );

            }
            
        }
    }

    return wind;

}
*/

vec4 get_source_wind_from_tex () {

    vec4 wind = vec4 (0.0, 0.0, 0.0, 0.0);
    bool done = true;

    vec2 texel_dim = vec2(float(BOARD_X) / float(TEX_X), float(BOARD_Y) / float(TEX_Y));
    vec2 tex_pos = gl_GlobalInvocationID.xy;

    for (int i=99; i >= 0 && done; i--) {

        vec4 holder = texelFetch (wind_texture, ivec2(3, i) , 0);
        
        if (holder.w == 0) done = false;
        else {
            
            vec2 source_dir = (holder.xy * 256.0) - tex_pos;
            vec2 source_dir_norm = normalize(source_dir) * texel_dim;
            vec4 normal = texelFetch(obstacle_normals_texture, ivec2(tex_pos), 0);

            holder.x = (holder.x * BOARD_X) - BOARD_X * 0.5;
            holder.y = (holder.y * BOARD_X) - BOARD_X * 0.5;
            holder.z = (holder.z * BOARD_Y) - BOARD_Y * 0.5;
            
            wind += 10 * sink_source_effect( -1, holder , normal);
            
        }
    }

    return wind;

}

void main() {

	ivec2 storeLoc = ivec2(gl_GlobalInvocationID.xy);

	vec4 stored = imageLoad( imageUnit, storeLoc );

	vec4 wind = vec4(0,0,0,0);

	switch (wind_type) {
		
		case 0:
			
			wind = random_intensity_fixed_direction();
			break;
		
		case 1:

			wind = vortex_effect( vec4(-1,-2,0,10) );
			break;

		case 2:

			wind = sink_source_effect( -1 , vec4( -5,6,0,10), vec4(0,0,0,0)); // source
			break;

		case 3:

			wind = sink_source_effect( 1 , vec4(-3,-3,0,10) , vec4(0,0,0,0)); // sink 
			break; 

        case 4:

            wind += get_cons_wind_from_tex();
            wind += get_vortex_wind_from_tex();
            wind += get_sink_wind_from_tex();            
            wind += get_source_wind_from_tex();

            break;
            
		default:

			wind = random_intensity_fixed_direction();
			break;

	} 

	imageStore(imageUnit, storeLoc, wind);
}